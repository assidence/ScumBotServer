//go:build windows

package execModules

import (
	"fmt"
	"image"
	"image/png"
	"log"
	"os"
	"syscall"
	"time"
	"unsafe"
)

var (
	user32dll       = syscall.NewLazyDLL("user32.dll")
	procFindWindowW = user32dll.NewProc("FindWindowW")
	procSendInputEx = user32dll.NewProc("SendInput")
)

var (
	dll               = syscall.NewLazyDLL("WindowCaptureDLL.dll")
	procCaptureWindow = dll.NewProc("CaptureWindowHWND")
)

type RECT struct{ Left, Top, Right, Bottom int32 }

func utf16Ptr(s string) *uint16 {
	ptr, _ := syscall.UTF16PtrFromString(s)
	return ptr
}

func findWindow(title string) (uintptr, error) {
	hwnd, _, _ := procFindWindowW.Call(0, uintptr(unsafe.Pointer(utf16Ptr(title))))
	if hwnd == 0 {
		return 0, fmt.Errorf("未找到窗口: %s", title)
	}
	return hwnd, nil
}

// -------------------- DLL 调用截图 --------------------
func captureWindowDLL(hwnd uintptr) (*image.RGBA, error) {
	var width, height int32
	// 假设先获取窗口尺寸
	width = 1280
	height = 720
	size := int(width * height * 4)
	buf := make([]byte, size)

	ret, _, err := procCaptureWindow.Call(hwnd,
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(unsafe.Pointer(&width)),
		uintptr(unsafe.Pointer(&height)))
	if ret == 0 {
		return nil, fmt.Errorf("DLL CaptureWindow 失败: %v", err)
	}

	img := image.NewRGBA(image.Rect(0, 0, int(width), int(height)))
	copy(img.Pix, buf)
	return img, nil
}

// -------------------- 模板匹配 --------------------
func loadTemplate(path string) image.Image {
	f, err := os.Open(path)
	if err != nil {
		log.Fatalf("无法加载模板: %s", path)
	}
	defer f.Close()
	img, _ := png.Decode(f)
	return img
}

func matchTemplate(img image.Image, tpl image.Image) (image.Point, bool) {
	iw, ih := img.Bounds().Dx(), img.Bounds().Dy()
	tw, th := tpl.Bounds().Dx(), tpl.Bounds().Dy()

	bestX, bestY := 0, 0
	bestScore := float64(-1)

	for y := 0; y <= ih-th; y += 5 {
		for x := 0; x <= iw-tw; x += 5 {
			var diff float64
			for ty := 0; ty < th; ty++ {
				for tx := 0; tx < tw; tx++ {
					r1, g1, b1, _ := img.At(x+tx, y+ty).RGBA()
					r2, g2, b2, _ := tpl.At(tx, ty).RGBA()
					dr := float64(int(r1>>8) - int(r2>>8))
					dg := float64(int(g1>>8) - int(g2>>8))
					db := float64(int(b1>>8) - int(b2>>8))
					diff += dr*dr + dg*dg + db*db
				}
			}
			score := diff / float64(tw*th)
			if bestScore < 0 || score < bestScore {
				bestScore = score
				bestX, bestY = x, y
			}
		}
	}
	return image.Pt(bestX, bestY), bestScore < 2000
}

// -------------------- 模拟输入 --------------------
func keyTap(scanCode uint16) {
	var input [2]struct {
		Type uint32
		Ki   struct {
			WVk, WScan  uint16
			DwFlags     uint32
			Time        uint32
			DwExtraInfo uintptr
		}
	}
	input[0].Type = 1
	input[0].Ki.WScan = scanCode
	input[0].Ki.DwFlags = 0x0008
	input[1].Type = 1
	input[1].Ki.WScan = scanCode
	input[1].Ki.DwFlags = 0x0008 | 0x0002
	procSendInputEx.Call(uintptr(len(input)), uintptr(unsafe.Pointer(&input[0])), unsafe.Sizeof(input[0]))
}

// -------------------- 主逻辑 --------------------
func AutoReConnect() {
	hwnd, err := findWindow("SCUM  ")
	if err != nil {
		log.Fatal(err)
	}

	okBtn := loadTemplate("./png/ok.png")
	continueBtn := loadTemplate("./png/continue.png")

	for {
		img, err := captureWindowDLL(hwnd)
		if err != nil {
			log.Println("截图失败:", err)
			time.Sleep(time.Second)
			continue
		}

		// 保存截图用于调试
		f, _ := os.Create("./png/debug_current.png")
		png.Encode(f, img)
		f.Close()

		if _, found := matchTemplate(img, okBtn); found {
			log.Println("检测到 OK 按钮 → 点击")
			// clickAt(p.X+5, p.Y+5)
		} else if _, found := matchTemplate(img, continueBtn); found {
			log.Println("检测到继续游戏按钮 → 点击")
			// clickAt(p.X+5, p.Y+5)
		} else {
			// 检查聊天框区域
			rSum, gSum, bSum := int64(0), int64(0), int64(0)
			chatRect := image.Rect(30, 30, 330, 180)
			for y := chatRect.Min.Y; y < chatRect.Max.Y; y++ {
				for x := chatRect.Min.X; x < chatRect.Max.X; x++ {
					r, g, b, _ := img.At(x, y).RGBA()
					rSum += int64(r >> 8)
					gSum += int64(g >> 8)
					bSum += int64(b >> 8)
				}
			}
			total := int64(chatRect.Dx() * chatRect.Dy())
			rAvg := float64(rSum) / float64(total)
			gAvg := float64(gSum) / float64(total)
			bAvg := float64(bSum) / float64(total)
			if rAvg+gAvg+bAvg < 30 {
				log.Println("聊天框未打开 → 按 T")
				keyTap(0x14)
			} else if bAvg < rAvg*1.4 || bAvg < gAvg*1.4 {
				log.Println("聊天框未蓝色 → 按 Tab")
				keyTap(0x0F)
			}
		}

		time.Sleep(time.Second) // 每秒一次
	}
}
